Toss slash 2021
Test code 효율성과 중요성
쿠버네티스, db 스케일 아웃, ORM
POD - 파드(Pod) 는 쿠버네티스에서 생성하고 관리할 수 있는 배포 가능한 가장 작은 컴퓨팅 단위
RDBMS와 Scale out -> 관계 데이 베이스의 확장
싱글톤 패턴 - 어플리케이션이 시작될 때 어떤 클래스가 최초 한번만 메모리를 할당(Static)그 메모리에 인스턴스를 만들어 사용하는 디자인 패턴.

MySQL, Postgres, Oracle등의 기존 RDBMS에서는 세 가지 Scale out 방법이 있다

- Replication(복제)
    - Master Node와 Slave Node를 따로 두어서, Master Node에 CUD 작업의 책임을 주고, Slave Node에 Read의 책임을 주는 것
    - Master → Slave의 방향으로 데이터가 전파됨
    - 상대적으로 다중화가 쉬운 Slave에 부하 분산이 목적
    - Single Master와 Multi Master Replication으로 나뉘어짐
    - Master 혹은 Slave 전체가 죽으면 제대로 동작하지 않음
- Clustering
    - 여러 DB Node를 두어 모든 노드가 전체 데이터를 저장하는 전략
    - 고가용성 시스템에 적절하고, 한 노드가 죽더라도 다른 노드에 저장된 데이터들이 온전히 존재함
    - 데이터 동기화에 추가적인 시간이 걸림 - Consistency(일관성), Latency(지연시간) 관련 문제 존재
    - 모든 노드가 전체 데이터를 가지고 있어 스토리지 차원에서 비효율적
- Sharding (하나의 거대한 데이터베이스나 네트워크 시스템을 여러 개의 작은 조각으로 나누어 분산 저장하여 관리하는 것)
    - 테이블의 데이터를 Hash 혹은 Range로 나누어서 Shard별로 Row들을 분산해서 저장하는 전략
    - 스토리지 차원에서 효율적
    - 특히 Row가 많을 경우 부하 분산에 효율적
    - MySQL 기준, **Shard간의 Cross Join이 불가**

실제로 올려본 경험은 없는 이유? 필요성을 못 느끼고 우리가 아는 DB에서 세팅이 어려워서..

- 필요성은 부하 테스트를 통해 만들 수 있음
- 세팅은 자체적으로 분산 시스템 구조를 적용하고 있는 RDBMS를 쓰면 쉬움
- MySQL, Postgres, Oracle은 Scale out의 필요성이 없었던 옛날에서는 최고였음
    - 그러나 Scale out을 통해 아키텍처가 분산화되는 현재는 놓아줘야 할 때
- DB 인스턴스를 꼭 하나만 둬야 할 이유는 없음. 
DB 인스턴스(가상 장비와 설치된 Microsoft SQL Server를 아우르는 개념으로, RDS for MS-SQL에서 제공하는 Microsoft SQL Server의 단위)
- DB를 꼭 위 셋중에 하나만 써야 할 이유도 없음

=================================================================================================

웹서버 vs WAS

웹 서버 - 클라이언트가 웹 브라우저에서 어떠한 페이지 요청으 하면 웹 서버에서 그 요청을 받아 정적 컨텐츠를 제공하는 서버.
정적 컨텐츠마 제공하는 것은 아니고 웹서벅 동적 컨텐으를 요청 받으면 WAS에게 해다 요청을 넘겨주고, WAS에서 처리하 결과르 클라이언트에 전달해주는 역할도 함.
ex) Apache

WAS - 웹 서버와 웹 컨테이너가 합쳐진 형태로, 웹 서버 단독으로는 처리할 수 없는 데이터베이스의 조회와 다양한 로직 처리가 필요한 동적컨텐츠 제공.
WAS느 JSP, Servlet 구동 환경을 제공해주기 때문에 웹 컨테인 혹은 서블릿 컨테이너라고도 불림.
웹 컨테이너 - 웹 서버가 보낸 JSP,PHP등 파일을 수행한 결과르 다시 웹서버로 보내주는 역할을 함
ex) Tomcat


OLTP vs OLAP

- Online Transaction Processing(OLTP)
    - WAS와 연동되는 비교적 소규모 데이터베이스에서 데이터 CRUD에 사용되는 쿼리
    - 트랜잭션이므로 ACID 요소가 중요시됨(트랜잭션 - 데이터베이스의 상태를 변경시키기 위해 수행하는 작업 단위)
    - 빠른 조회 등의 지연시간 처리 중요함
    - 다운타임 없이 트랜잭션 처리와 데이터 무결성에 안정적이어야 함
- Online Analytical Processing(OLAP)
    - 데이터 웨어하우스등 큰 규모의 데이터베이스에서 데이터 분석에 사용되는 쿼리
    - 레이턴시는 상대적으로 중요하지 않음
Refactoring - 공학에서 '결과의 변경 없이 코드의 구조를 재조정함'을 뜻한다. 주로 가독성을 높이고 유지보수를 편하게 한다
=================================================================================================
OAuth(Open Authentification)2.0 - 웹, 앱 서비스에서 제한적으로 권한을 요청해 사용할 수 있는 키를 발급해주는 것
인증뿐만 아니라 사용자의 권한에 따라 접근할 수 있는 데이터가 드라도록 설정할 수 있는 “범용 프레임워크”이다.

Amazon Elastic Container Registry(Amazon ECR)는 안전하고 확장 가능하고 신뢰할 수 있는 AWS 관리형 컨테이너 이미지 레지스트리 서비스입니다. 
Amazon ECR은 AWS IAM을 사용하여 리소스 기반 권한을 가진 프라이빗 리포지토리를 지원합니다. 따라서 지정된 사용자 또는 Amazon 
EC2 인스턴스가 컨테이너 리포지토리 및 이미지에 액세스할 수 있습니다. 원하는 CLI를 사용하여 도커 이미지,
Open Container Initiative(OCI) 이미지 및 OCI 호환 아티팩트를 푸시, 풀 및 관리할 수 있습니다.

Amazon Elastic Kubernetes Service(Amazon EKS)는 Kubernetes를 실행하는 데 사용할 수 있는 관리형 서비스입니다. 
AWS Kubernetes 제어 플레인 또는 노드를 설치, 작동 및 유지 관리할 필요가 없습니다. Kubernetes는 컨테이너화된 애플리케이션의 배포, 
조정 및 관리 자동화를 위한 오픈 소스 시스템입니다. 

Amazon Elastic Compute Cloud(Amazon EC2)는 안전하고 크기 조정이 가능한 컴퓨팅 용량을 클라우드에서 제공하는 웹 서비스입니다.
AMI (Amazon Machine Images)는 EC2 인스턴스를 시작하는 데 필요한 정보가 들어있는 이미지 즉 EC2의 복사본 이라고 생각하시면 됩니다.

==================================================================================================

Test code Tip

1. given, when, then
2. 모든 response에 대한 테스트를 진행한다.
3. First 
Fast - 단위 테스트는 가능한 빠르게 실행되어야 한다. 
Independent - 단위 테스트는 객체의 상태, 메소드, 이전 테스트 상태, 다른 메소드의 결과등에 의존해서는 안된다. 어떠한 순서 상관 없이 성공해야함
Repeatable - 반복 가능해야한다. DB에 의존하는 테스트는 수행 후 자동으로 롤백을 한다는 등의 별도 설정이 필요하다.
Self-validating - 단위테스트는 자체 검증이 가능해야한다. 테스트를 개발자가 직접 수동으로 확인할 필요 없이 ,Assert문 등에 의해 성공여부가 결과로 나와야한다.
Timely - 단위테스트를 통과하는 제품코드가 작성되기 바로전에 단위 테스트를 작성해야한다. TDD를 하고 있다면 적용이 되지만 그렇지 않을 수도 있다.

TDD - 테스트가 주도하는 개발 - 실패하는 테스트코드 작성 -> 테스트가 성공하는 프로덕션코드 작성 -> 테스트가 성공하면 프로덕션 코드를 리팩토링 하는식으로 개발방법
====================================================================================================================
Java Algorithm

<int vs Integer>

int(primitive type)
-int는 변수의 타입
변수(variable)는 값을 저장할 수 있는 메모리 상의 공간, int 와 char가 변수의 형을 지정해주고 있는 것이 변수의 타입.
자료형은 'data의 type에 따라 값이 저장될 공간의 크기와 저장 형식을 정의한 것
산술 연산 가능, null로 초기화 불가

Integer(wrapper class)
기본형을 객체로 다루기 위해 사용하는 클래스들을 래퍼 클래스 ex) Integer는 int의 레퍼클레스
Unboxing하지 않을 시 산술 연산 불가능, null값 처리 가능

<StringBuilder>
String을 +연산으로 붙이지 말고 StringBuilder를 이용하면 수행시간을 더 줄일 수 있다.

<문자를 정수로>
문자 1 = 아스키코드(49)
문자 2 = 아스키코드(50)
문자 3 = 아스키코드(51)

so 여기에 '0'을 빼주면 정수로 변환
ex) charAt(i)-'0'

<StringBuilder>

sb.append(값)
- StringBuffer, StringBuilder 뒤에 값을 붙인다
 
sb.insert(인덱스, 값)
- 특정 인덱스부터 값을 삽입한다
 
sb.delete(인덱스, 인덱스)
- 특정 인덱스부터 인덱스까지 값을 삭제한다
 
sb.indexOf(값)
- 값이 어느 인덱스에 들어있는지 확인한다
 
sb.substring(인덱스, 인덱스)
- 인덱스부터 인덱스까지 값을 잘라온다
 
sb.length()
- 길이 확인
 
sb.replace(인덱스, 인덱스, 값)
- 인덱스부터 인덱스까지 값으로 변경
 
sb.reverse()
- 글자 순서를 뒤집는다
 
이제 간단히 정리해 보자면
 
<String에서 concat, + 사용 시 속도가 왜 느려지나>
=> String은 불변(immutable)하기 때문에 concat, + 사용 시 기존 값을 버리고 새로 할당해서 1000번 이상 수행할 경우 급격히 느려짐
 
<StringBuffer, StringBuilder를 사용하는 이유> 
=> String에서 concat, +를 천번 이상 사용할 경우 속도가 급격히 느려지기 때문에 해당 상황에는
변하는(mutable) StringBuffer와 StringBuilder를 사용한다
 
<StringBuffer, StringBuilder의 차이> 
=> StringBuffer는 공통 메소드 동기화로 인해 멀티 스레드 환경에서만 사용 그 외에는 StringBuilder를 사용하면 됨

====================================================
토큰 관련 참고 글 : https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=jmjm223&logNo=221483149513

슬라이스(Slice) 테스트
-슬라이스(Slice) 테스트를 한다는 건 특정 Layer를 타켓으로 테스트를 한다는 뜻이다.ex) Controller Layer, Service Layer

