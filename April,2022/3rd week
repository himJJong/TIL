쿠버네티스, docker swam, api 

<notion 주긴 미팅에서>
애플리케이션

- 프론트와 백엔드 각각 Pod로 나누어서 쓸 예정
- DB를 어디에 놓느냐가 조금 고민. 개인적으로는 개발 환경도 컨테이너화 시키기 쉽다면 개발 환경에서 로컬 DB를 사용하고, 프로덕션 환경에서는 AWS RDS를 쓰는게 나을 듯함
- 반대로 설계한다면 여러명이 동시에 작업하시면 RDS의 스키마가 꼬일 가능성이 존재

모니터링

- Prometheus는 대규모 트래픽 다룰 때 확장에 문제가 있어서, Thanos 사용 예정
    - 프로메테우스의 철학을 따르면서 수평적 확장이 쉽게 만든 모니터링 컨테이너

로깅

- ELK는 너무 무겁다. swap 메모리도 거의 안먹고, 램을 많이 차지함
- grafana 제작사에서 제공해주는 Loki 쓰면 문제 없이, 스케일링 쉽게 바로 될 듯 함

시각화

- grafana만한 게 없어서 grafana에 Thanos, Loki 연동해주는 플러그인 올려서 사용

Continuous Deployment / GitOps

두 가지 파트로 분리됨

1. 이미지 빌드 후 리모트 레지스트리에 업로드
    - 여기서는 Github Actions에 docker, docker-compose를 빌드 툴로 사용
    - 리모트 레포지토리 main 브랜치가 변경이 되면 이미지 빌드 후 AWS ECR 이미지 레지스트리에 바로 업로드 (읽기 권한은 Public이어도 괜찮을 듯 함)

1. 쿠버네티스 클러스터에 있는 이미지를 레지스트리의 최신 이미지로 Sync 및 클러스터 정의를 Git과 동기화
    - ArgoCD를 클러스터에 띄워두고 Github 레포 주소 세팅해서 Helm, Kustomize등으로 짜둔 클러스터 정의를 Pull 방식으로 동기화
    - 마찬가지로 ArgoCD를 통해 AWS ECR 레지스트리에 있는 최신 이미지와 Pull 방식으로 동기화
    
    
    
Spring 

Annotation 이란?
Annotation(@)은 사전적 의미로는 주석이라는 뜻이다.
자바에서 Annotation은 코드 사이에 주석처럼 쓰이며 특별한 의미, 기능을 수행하도록 하는 기술이다.
즉, 프로그램에게 추가적인 정보를 제공해주는 메타데이터라고 볼 수 있다.
meta data : 데이터를 위한 데이터)

다음은 어노테이션의 용도를 나타낸 것이다.

컴파일러에게 코드 작성 문법 에러를 체크하도록 정보를 제공한다.

소프트웨어 개발 툴이 빌드나 배치시 코드를 자동으로 생성할 수 있도록 정보를 제공한다.

실행시(런타임시)특정 기능을 실행하도록 정보를 제공한다.

기본적으로 어노테이션을 사용하는 순서는 다음과 같다.

어노테이션을 정의한다.

클래스에 어노테이션을 배치한다.

코드가 실행되는 중에 Reflection을 이용하여 추가 정보를 획득하여 기능을 실시

Reflection이란 프로그램이 실행 중에 자신의 구조와 동작을 검사하고, 조사하고, 수정하는 것이다.


Reflection은 프로그래머가 데이터를 보여주고, 다른 포맷의 데이터를 처리하고, 
통신을 위해 serialization(직렬화)를 수행하고, bundling을 하기 위해 일반 소프트웨어 라이브러리를 만들도록 도와준다.

Annotation 종류
@ComponentScan
@Component와 @Service, @Repository, @Controller, @Configuration이 붙은 클래스 Bean들을 찾아서 Context에 bean등록을 해주는 Annotation이다.
@Component Annotation이 있는 클래스에 대하여 bean 인스턴스를 생성

ApplicationContext.xml에 <bean id="jeongpro" class="jeongpro" /> 과 같이 xml에 bean을 직접등록하는 방법도 있고 위와 같이 Annotation을 붙여서 하는 방법도 있다.

base-package를 넣으면 해당 패키지 아래에 있는 컴포넌트들을 찾고 그 과정을 spring-context-버전(4.3.11.RELEASE).jar에서 처리한다.

Spring에서 @Component로 다 쓰지 않고 @Repository, @Service, @Controller등을 사용하는 이유는, 예를들어 @Repository는 DAO의 메소드에서 발생할 수 있는 unchecked exception들을 스프링의 DataAccessException으로 처리할 수 있기 때문이다.

또한 가독성에서도 해당 애노테이션을 갖는 클래스가 무엇을 하는지 단 번에 알 수 있다.

자동으로 등록되는 Bean의 이름은 클래스의 첫문자가 소문자로 바뀐 이름이 자동적용된다.
HomeController -> homeController

@Component
@Component 은 개발자가 직접 작성한 Class를 Bean으로 등록하기 위한 Annotation이다.

@Component
public class Student {
    public Student() {
        System.out.println("hi");
    }
}

@Component(value="mystudent")
public class Student {
    public Student() {
        System.out.println("hi");
    }
}
Component에 대한 추가 정보가 없다면 Class의 이름을 camelCase로 변경한 것이 Bean id로 사용된다.

하지만 @Bean과 다르게 @Component는 name이 아닌 value를 이용해 Bean의 이름을 지정한다.

@Bean
@Bean은 개발자가 직접 제어가 불가능한 외부 라이브러리등을 Bean으로 만들려할 때 사용되는 Annotation이다.

@Configuration
public class ApplicationConfig {    
    @Bean
    public ArrayList<String> array(){
        return new ArrayList<String>();
    }   
}
ArrayList같은 라이브러리등을 Bean으로 등록하기 위해서는 별도로 해당 라이브러리 객체를 반환하는 Method를 만들고 @Bean Annotation을 사용하면 된다.

위의 경우 @Bean에 아무런 값을 지정하지 않았으므로 Method 이름을 camelCase로 변경한 것이 Bean id로 등록된다.
method 이름이 arrayList()인 경우 arrayList가 Bean id

@Configuration
public class ApplicationConfig {    
    @Bean(name="myarray")
    public ArrayList<String> array(){
        return new ArrayList<String>();
    }   
}
위와 같이 @Bean에 name이라는 값을 이용하면 자신이 원하는 id로 Bean을 등록할 수 있다.

@Autowired
속성(field), setter method, constructor(생성자)에서 사용하며 Type에 따라 알아서 Bean을 주입 해준다.
무조건적인 객체에 대한 의존성을 주입시킨다.
이 Annotation을 사용할 시, 스프링이 자동적으로 값을 할당한다.
Controller 클래스에서 DAO나 Service에 관한 객체들을 주입 시킬 때 많이 사용한다.

필드, 생성자, 입력 파라미터가 여러 개인 메소드(@Qualifier는 메소드의 파라미터)에 적용 가능하다.

Type을 먼저 확인한 후 못 찾으면 Name에 따라 주입한다.
Name으로 강제하는 방법: @Qualifier을 같이 명시

Bean을 주입받는 방식 (3가지)

@Autowired
setter
생성자 (@AllArgsConstructor 사용) -> 권장방식


참고한 자료 및 더 볼 velog : https://velog.io/@gillog/Spring-Annotation-정리
