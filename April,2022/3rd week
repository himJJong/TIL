쿠버네티스, docker swam, api 

<notion 주긴 미팅에서>
애플리케이션

- 프론트와 백엔드 각각 Pod로 나누어서 쓸 예정
- DB를 어디에 놓느냐가 조금 고민. 개인적으로는 개발 환경도 컨테이너화 시키기 쉽다면 개발 환경에서 로컬 DB를 사용하고, 프로덕션 환경에서는 AWS RDS를 쓰는게 나을 듯함
- 반대로 설계한다면 여러명이 동시에 작업하시면 RDS의 스키마가 꼬일 가능성이 존재

모니터링

- Prometheus는 대규모 트래픽 다룰 때 확장에 문제가 있어서, Thanos 사용 예정
    - 프로메테우스의 철학을 따르면서 수평적 확장이 쉽게 만든 모니터링 컨테이너

로깅

- ELK는 너무 무겁다. swap 메모리도 거의 안먹고, 램을 많이 차지함
- grafana 제작사에서 제공해주는 Loki 쓰면 문제 없이, 스케일링 쉽게 바로 될 듯 함

시각화

- grafana만한 게 없어서 grafana에 Thanos, Loki 연동해주는 플러그인 올려서 사용

Continuous Deployment / GitOps

두 가지 파트로 분리됨

1. 이미지 빌드 후 리모트 레지스트리에 업로드
    - 여기서는 Github Actions에 docker, docker-compose를 빌드 툴로 사용
    - 리모트 레포지토리 main 브랜치가 변경이 되면 이미지 빌드 후 AWS ECR 이미지 레지스트리에 바로 업로드 (읽기 권한은 Public이어도 괜찮을 듯 함)

1. 쿠버네티스 클러스터에 있는 이미지를 레지스트리의 최신 이미지로 Sync 및 클러스터 정의를 Git과 동기화
    - ArgoCD를 클러스터에 띄워두고 Github 레포 주소 세팅해서 Helm, Kustomize등으로 짜둔 클러스터 정의를 Pull 방식으로 동기화
    - 마찬가지로 ArgoCD를 통해 AWS ECR 레지스트리에 있는 최신 이미지와 Pull 방식으로 동기화
    
    
    
Spring 

Annotation 이란?
Annotation(@)은 사전적 의미로는 주석이라는 뜻이다.
자바에서 Annotation은 코드 사이에 주석처럼 쓰이며 특별한 의미, 기능을 수행하도록 하는 기술이다.
즉, 프로그램에게 추가적인 정보를 제공해주는 메타데이터라고 볼 수 있다.
meta data : 데이터를 위한 데이터)

다음은 어노테이션의 용도를 나타낸 것이다.

컴파일러에게 코드 작성 문법 에러를 체크하도록 정보를 제공한다.

소프트웨어 개발 툴이 빌드나 배치시 코드를 자동으로 생성할 수 있도록 정보를 제공한다.

실행시(런타임시)특정 기능을 실행하도록 정보를 제공한다.

기본적으로 어노테이션을 사용하는 순서는 다음과 같다.

어노테이션을 정의한다.

클래스에 어노테이션을 배치한다.

코드가 실행되는 중에 Reflection을 이용하여 추가 정보를 획득하여 기능을 실시

Reflection이란 프로그램이 실행 중에 자신의 구조와 동작을 검사하고, 조사하고, 수정하는 것이다.


참고한 자료 및 더 볼 velog : https://velog.io/@gillog/Spring-Annotation-정리
