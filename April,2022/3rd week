쿠버네티스, docker swam, api 

<notion 주긴 미팅에서>
애플리케이션

- 프론트와 백엔드 각각 Pod로 나누어서 쓸 예정
- DB를 어디에 놓느냐가 조금 고민. 개인적으로는 개발 환경도 컨테이너화 시키기 쉽다면 개발 환경에서 로컬 DB를 사용하고, 프로덕션 환경에서는 AWS RDS를 쓰는게 나을 듯함
- 반대로 설계한다면 여러명이 동시에 작업하시면 RDS의 스키마가 꼬일 가능성이 존재

모니터링

- Prometheus는 대규모 트래픽 다룰 때 확장에 문제가 있어서, Thanos 사용 예정
    - 프로메테우스의 철학을 따르면서 수평적 확장이 쉽게 만든 모니터링 컨테이너

로깅

- ELK는 너무 무겁다. swap 메모리도 거의 안먹고, 램을 많이 차지함
- grafana 제작사에서 제공해주는 Loki 쓰면 문제 없이, 스케일링 쉽게 바로 될 듯 함

시각화

- grafana만한 게 없어서 grafana에 Thanos, Loki 연동해주는 플러그인 올려서 사용

Continuous Deployment / GitOps

두 가지 파트로 분리됨

1. 이미지 빌드 후 리모트 레지스트리에 업로드
    - 여기서는 Github Actions에 docker, docker-compose를 빌드 툴로 사용
    - 리모트 레포지토리 main 브랜치가 변경이 되면 이미지 빌드 후 AWS ECR 이미지 레지스트리에 바로 업로드 (읽기 권한은 Public이어도 괜찮을 듯 함)

1. 쿠버네티스 클러스터에 있는 이미지를 레지스트리의 최신 이미지로 Sync 및 클러스터 정의를 Git과 동기화
    - ArgoCD를 클러스터에 띄워두고 Github 레포 주소 세팅해서 Helm, Kustomize등으로 짜둔 클러스터 정의를 Pull 방식으로 동기화
    - 마찬가지로 ArgoCD를 통해 AWS ECR 레지스트리에 있는 최신 이미지와 Pull 방식으로 동기화
    
    
    
Spring 

Annotation 이란?
Annotation(@)은 사전적 의미로는 주석이라는 뜻이다.
자바에서 Annotation은 코드 사이에 주석처럼 쓰이며 특별한 의미, 기능을 수행하도록 하는 기술이다.
즉, 프로그램에게 추가적인 정보를 제공해주는 메타데이터라고 볼 수 있다.
meta data : 데이터를 위한 데이터)

다음은 어노테이션의 용도를 나타낸 것이다.

컴파일러에게 코드 작성 문법 에러를 체크하도록 정보를 제공한다.

소프트웨어 개발 툴이 빌드나 배치시 코드를 자동으로 생성할 수 있도록 정보를 제공한다.

실행시(런타임시)특정 기능을 실행하도록 정보를 제공한다.

기본적으로 어노테이션을 사용하는 순서는 다음과 같다.

어노테이션을 정의한다.

클래스에 어노테이션을 배치한다.

코드가 실행되는 중에 Reflection을 이용하여 추가 정보를 획득하여 기능을 실시

Reflection이란 프로그램이 실행 중에 자신의 구조와 동작을 검사하고, 조사하고, 수정하는 것이다.


Reflection은 프로그래머가 데이터를 보여주고, 다른 포맷의 데이터를 처리하고, 
통신을 위해 serialization(직렬화)를 수행하고, bundling을 하기 위해 일반 소프트웨어 라이브러리를 만들도록 도와준다.

Annotation 종류
@ComponentScan
@Component와 @Service, @Repository, @Controller, @Configuration이 붙은 클래스 Bean들을 찾아서 Context에 bean등록을 해주는 Annotation이다.
@Component Annotation이 있는 클래스에 대하여 bean 인스턴스를 생성

ApplicationContext.xml에 <bean id="jeongpro" class="jeongpro" /> 과 같이 xml에 bean을 직접등록하는 방법도 있고 위와 같이 Annotation을 붙여서 하는 방법도 있다.

base-package를 넣으면 해당 패키지 아래에 있는 컴포넌트들을 찾고 그 과정을 spring-context-버전(4.3.11.RELEASE).jar에서 처리한다.

Spring에서 @Component로 다 쓰지 않고 @Repository, @Service, @Controller등을 사용하는 이유는, 예를들어 @Repository는 DAO의 메소드에서 발생할 수 있는 unchecked exception들을 스프링의 DataAccessException으로 처리할 수 있기 때문이다.

또한 가독성에서도 해당 애노테이션을 갖는 클래스가 무엇을 하는지 단 번에 알 수 있다.

자동으로 등록되는 Bean의 이름은 클래스의 첫문자가 소문자로 바뀐 이름이 자동적용된다.
HomeController -> homeController

@Component
@Component 은 개발자가 직접 작성한 Class를 Bean으로 등록하기 위한 Annotation이다.

@Component
public class Student {
    public Student() {
        System.out.println("hi");
    }
}

@Component(value="mystudent")
public class Student {
    public Student() {
        System.out.println("hi");
    }
}
Component에 대한 추가 정보가 없다면 Class의 이름을 camelCase로 변경한 것이 Bean id로 사용된다.

하지만 @Bean과 다르게 @Component는 name이 아닌 value를 이용해 Bean의 이름을 지정한다.

@Bean
@Bean은 개발자가 직접 제어가 불가능한 외부 라이브러리등을 Bean으로 만들려할 때 사용되는 Annotation이다.

@Configuration
public class ApplicationConfig {    
    @Bean
    public ArrayList<String> array(){
        return new ArrayList<String>();
    }   
}
ArrayList같은 라이브러리등을 Bean으로 등록하기 위해서는 별도로 해당 라이브러리 객체를 반환하는 Method를 만들고 @Bean Annotation을 사용하면 된다.

위의 경우 @Bean에 아무런 값을 지정하지 않았으므로 Method 이름을 camelCase로 변경한 것이 Bean id로 등록된다.
method 이름이 arrayList()인 경우 arrayList가 Bean id

@Configuration
public class ApplicationConfig {    
    @Bean(name="myarray")
    public ArrayList<String> array(){
        return new ArrayList<String>();
    }   
}
위와 같이 @Bean에 name이라는 값을 이용하면 자신이 원하는 id로 Bean을 등록할 수 있다.

@Autowired
속성(field), setter method, constructor(생성자)에서 사용하며 Type에 따라 알아서 Bean을 주입 해준다.
무조건적인 객체에 대한 의존성을 주입시킨다.
이 Annotation을 사용할 시, 스프링이 자동적으로 값을 할당한다.
Controller 클래스에서 DAO나 Service에 관한 객체들을 주입 시킬 때 많이 사용한다.

필드, 생성자, 입력 파라미터가 여러 개인 메소드(@Qualifier는 메소드의 파라미터)에 적용 가능하다.

Type을 먼저 확인한 후 못 찾으면 Name에 따라 주입한다.
Name으로 강제하는 방법: @Qualifier을 같이 명시

Bean을 주입받는 방식 (3가지)

@Autowired
setter
생성자 (@AllArgsConstructor 사용) -> 권장방식

@Inject
@Autowired 어노테이션과 비슷한 역할을 한다.

@Controller
Spring의 Controller를 의미한다. Spring MVC에서 Controller클래스에 쓰인다.

@RestController
Spring에서 Controller 중 View로 응답하지 않는, Controller를 의미한다.

method의 반환 결과를 JSON 형태로 반환한다.

이 Annotation이 적혀있는 Controller의 method는 HttpResponse로 바로 응답이 가능하다.
@ResponseBody 역할을 자동적으로 해주는 Annotation이다.
@Controller + @ResponseBody를 사용하면 @ResponseBody를 모든 메소드에서 적용한다.

@Controller 와 @RestController 의 차이

@Controller
API와 view를 동시에 사용하는 경우에 사용한다.
대신 API 서비스로 사용하는 경우는 @ResponseBody를 사용하여 객체를 반환한다.
view(화면) return이 주목적이다.

@RestController
view가 필요없는 API만 지원하는 서비스에서 사용한다.
Spring 4.0.1부터 제공
@RequestMapping 메서드가 기본적으로 @ResponseBody 의미를 가정한다.
data(json, xml 등) return이 주목적이다.

즉, @RestController = @Controller + @ResponseBody 이다.

@Service
Service Class에서 쓰인다.
비즈니스 로직을 수행하는 Class라는 것을 나타내는 용도이다.

@Repository
DAO class에서 쓰인다.
DataBase에 접근하는 method를 가지고 있는 Class에서 쓰인다.

@EnableAutoConfiguration
Spring Application Context를 만들 때 자동으로 설정하는 기능을 켠다.

classpath의 내용에 기반해서 자동으로 생성해준다.

만약 tomcat-embed-core.jar가 존재하면 톰캣 서버가 setting된다.

@Configuration
@Configuration을 클래스에 적용하고 @Bean을 해당 Class의 method에 적용하면 @Autowired로 Bean을 부를 수 있다.

@Required
setter method에 적용해주면 Bean 생성시 필수 프로퍼티 임을 알린다.

Required Annotation을 사용하여 optional 하지 않은, 꼭 필요한 속성들을 정의한다.

영향을 받는 bean property를 구성할 시에는 XML 설정 파일에 반드시 property를 채워야 한다.
엄격한 체크, 그렇지 않으면 BeanInitializationException 예외를 발생

<!-- Definition for student bean -->
<bean id = "student" class = "com.tutorialspoint.Student">
    <property name = "name" value = "Zara" />
    <property name = "age"  value = "11"/>
</bean>
@Qualifier("id123")
@Autowired와 같이 쓰이며, 같은 타입의 Bean 객체가 있을 때 해당 아이디를 적어 원하는 Bean이 주입될 수 있도록 하는 Annotation이다.
같은 타입이 존재하는 경우 ex) 동물 = 원숭이, 닭, 개, 돼지

같은 타입의 Bean이 두 개 이상이 존재하는 경우에 Spring이 어떤 Bean을 주입해야 할지 알 수 없어서 Spring Container를 초기화하는 과정에서 예외를 발생시킨다.

이 경우 @Qualifier을 @Autowired와 함께 사용하여 정확히 어떤 bean을 사용할지 지정하여 특정 의존 객체를 주입할 수 있도록 한다.

예시


xml 설정에서 bean의 한정자 값(qualifier value)을 설정한다.
@Autowired 어노테이션이 적용된 주입 대상에 @Qualifier 어노테이션을 설정한다.

참고한 자료 및 더 볼 velog : https://velog.io/@gillog/Spring-Annotation-정리


