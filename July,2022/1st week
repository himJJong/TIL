boolean 초기값은 False

만약 3 5 이렇게 입력받을시
String[] inputs = br.readLine().split(" ");

int num1 = Integer.parseInt(inputs[0]);
int num2 = Integer.parseInt(inputs[1]);

이렇게 쓰면 편함, 그래서 일반적으로 100만 개 이하일 경우에 완전탐색 알고리즘을 사용하면 가장 적절

ArrayList - 공간활동이 능동적이다. 단점 삭제시 앞으로 당겨야 하는 점

ArrayList - > 조회할 때 사용하면 좋음 O(1)                     LinkedList - > 추가하거나 삭제할 때 사용하면 좋음 O(1)
Priority Queue 는 값을 추가하거나 빼면 항상 우선순위에 맞게 정렬된 상태이기에 우선순위를 중요하게 생각하는 문제에서 유용하다.

스위핑 알고리즘 - 어떤 선이나 공간을 한쪽에서 부터 쓸어버린다. - 한 번만 전체 공간을 스캔하면서 마주치는 요소
들에 대해 뭔가를 해주면 정답이 구해지는 형태.시간복잡도 O(NlogN)

DFS(깊이우선탐색)	
현재 정점에서 갈 수 있는 점들까지 들어가면서 탐색	
스택 또는 재귀함수로 구현	
각각의 경로마다 특징을 저장해둬야 할 때는 DFS를 사용
검색 대상 그래프가 정말 크다면 DFS를 고려

BFS(너비우선탐색)
현재 정점에 연결된 가까운 점들부터 탐색
큐를 이용해서 구현
미로 찾기 등 최단거리를 구해야 할 경우, BFS가 유리
검색대상의 규모가 크지 않고, 검색 시작 지점으로부터 원하는 대상이 별로 멀지 않다면 BFS

https://www.youtube.com/watch?v=BsYbdUnKZ-Y
개발자로 취직하기 

완전 탐색
1. 함수 정의가 50%
2. 고를 수 있는 값의 종류 파악하기
3. 중복을 허용하는지
4. 순서가 중요한 지


int형 범위  =  -21억 ~ 21억

* 백트래킹(Backtracking) 해를 찾아가는 도중, 지금의 경로가 해가 될 것 같지 않으면 그 경로를 더이상 가지 않고 되돌아갑니다.
즉, 코딩에서는 반복문의 횟수까지 줄일 수 있으므로 효율적입니다.이를 가지치기라고 하는데, 불필요한 부분을 쳐내고 최대한 올바른 
쪽으로 간다는 의미입니다.일반적으로, 불필요한 경로를 조기에 차단할 수 있게 되어 경우의 수가 줄어들지만, 만약 N!의 경우의 수를 
가진 문제에서 최악의 경우에는 여전히 지수함수 시간을 필요로 하므로 처리가 불가능 할 수도 있습니다. 가지치기를 얼마나 잘하느냐에 
따라 효율성이 결정되게 됩니다.

===================================================================================================
프로그래머스 = 스택, 큐 / 해시, 정렬, 완전탐색, Bfs/Dfs
			greedy, 이분탐색

백준 = 자료구조, 프루트포스, 정렬, Dfs/Bfs, 그리디 이분탐색
===================================================================================================
