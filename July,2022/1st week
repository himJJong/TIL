boolean 초기값은 False

만약 3 5 이렇게 입력받을시
String[] inputs = br.readLine().split(" ");

int num1 = Integer.parseInt(inputs[0]);
int num2 = Integer.parseInt(inputs[1]);

이렇게 쓰면 편함, 그래서 일반적으로 100만 개 이하일 경우에 완전탐색 알고리즘을 사용하면 가장 적절

ArrayList - 공간활동이 능동적이다. 단점 삭제시 앞으로 당겨야 하는 점

ArrayList - > 조회할 때 사용하면 좋음 O(1)                     LinkedList - > 추가하거나 삭제할 때 사용하면 좋음 O(1)
Priority Queue 는 값을 추가하거나 빼면 항상 우선순위에 맞게 정렬된 상태이기에 우선순위를 중요하게 생각하는 문제에서 유용하다.

스위핑 알고리즘 - 어떤 선이나 공간을 한쪽에서 부터 쓸어버린다. - 한 번만 전체 공간을 스캔하면서 마주치는 요소
들에 대해 뭔가를 해주면 정답이 구해지는 형태.시간복잡도 O(NlogN)

DFS(깊이우선탐색)	
현재 정점에서 갈 수 있는 점들까지 들어가면서 탐색	
스택 또는 재귀함수로 구현	
각각의 경로마다 특징을 저장해둬야 할 때는 DFS를 사용
검색 대상 그래프가 정말 크다면 DFS를 고려

BFS(너비우선탐색)
현재 정점에 연결된 가까운 점들부터 탐색
큐를 이용해서 구현
미로 찾기 등 최단거리를 구해야 할 경우, BFS가 유리
검색대상의 규모가 크지 않고, 검색 시작 지점으로부터 원하는 대상이 별로 멀지 않다면 BFS

https://www.youtube.com/watch?v=BsYbdUnKZ-Y
